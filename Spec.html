<h1>Animation Proxy</h1>
<pre clas='metadata'>
  Status: ED
  ED: https://docs.google.com/a/chromium.org/document/d/1Zd7WU2gw6F0BkY_f7FdXBlc0ARJFxTFH-FlpIy
  Shortname: anim-proxy
  Level: 1
  Editor: Ian Vollick, Google, vollick@chromium.org
  Abstract: An animation proxy provides asynchronous access to certain layout-and-style-recalc-free properties. It may be used on a web worker thread.
  Ignored Terms: Promise, Element, DOMMatrix, WebWorker
</pre>
<h2 id="introduction">Introduction</h2>
JavaScript-driven animations are extremely flexible and powerful, but are subject to <a>main thread</a> <a>jank</a> (by <dfn>jank</dfn>, we mean unpredictable interruptions in the rate that animations are serviced on a thread due to other, unrelated work on that thread, and by <dfn>main thread</dfn> we refer to the thread on which JavaScript may access the DOM). And although JavaScript can run on a web worker, DOM access and CSS property animations are not permitted. <a>Main thread</a> animations are still widely used despite the fact that they are susceptible to jank; they are the only way to create common effects such as parallax, position-sticky, image carousels, custom scroll animations, iphone-style contact lists, and physics-based animations. In a perfect world, the <a>main thread</a> would always be responsive enough to guarantee that a JavaScript animation callback would be serviced every frame. In reality, this is extremely hard to achieve, both for user agents and developers of large sites composed of disparate components. The result is that many pages are unnecessarily janky.

Access to the DOM from JavaScript is not thread safe, and although it is possible to parallelize certain operations such as layout, allowing layout-dependant properties to be modified from multiple threads leads to contention. There are, however, certain <a>layout free</a> properties that could be modified asynchronously from other threads without contention. A <dfn>layout free</dfn> CSS property, is any property that may be changed without incurring a layout or or a style recalc. These properties currently include transform, opacity and scroll offset. Virtually all user agents support these accelerated CSS properties (i.e., properties that may be animated on another thread) and increasingly support threaded scrolling. This is possible by making use of a browser component commonly called a <dfn>compositor</dfn>, which may modify these values without involving the <a>main thread</a>. Clearly identifying these <a>layout free</a> properties and allowing them to be animated from any thread would provide a simple and powerful way to achieve smooth animations, even in the face of unpredictable <a>main thread</a> work.

This document proposes a new primitive, <a interface>AnimationProxy</a>, which permits a <a href="http://www.w3.org/TR/workers/">WebWorker</a> to directly communicate with the compositor component without involving the <a>main thread</a>.

<h2 id="dom-interfaces">DOM Interfaces</h2>

<h3 id="creation-of-animation-proxies">AnimationProxy Creation</h3>

<a interface>AnimationProxy</a> instances are obtained from DOM elements using the following interface.

<pre class='idl'>
interface AnimationProxyProvider {
    // TODO: should this return null, undefined or throw an exception if it fails?
    AnimationProxy getAnimationProxy();
};

Element implements AnimationProxyProvider;
</pre>

NOTE: An <a interface>AnimationProxy</a> may be created for any element whose transform can be animated using a CSS transition (i.e., block level elements). If <a method title="getAnimationProxy()">getAnimationProxy</a> is called on an unsuitable element, it will return undefined.

NOTE: As with 3d transforms, the creation of an <a interface>AnimationProxy</a> will force the element to establish a stacking context. It will also act as the containing block for any fixed position descendants. See this section of the <a href="http://www.w3.org/TR/css3-transforms/#transform-rendering">transform specification</a> for more information on the effect on fixed position elements.

<h3 id="animation-proxy-interface">The AnimationProxy Interface</h3>

The <a interface>AnimationProxy</a> is designed to permit asynchronous communication between web worker threads and the compositor component. Being an asynchronous API, it naturally deals in <a interface>Promise</a> objects. The <dfn interface>Promise</dfn> interface is defined in <a href="https://github.com/domenic/promises-unwrapping">this spec</a>. The error attribute of the <a interface>Promise</a> objects will be set to an enumerator of <a enum>AnimationProxyErrors</a> if the <a interface>Promise</a> is rejected. If the <a interface>Promise</a>'s accept callback is invoked, the value attribute of the <a interface>Promise</a> object will be void for the set functions and for the get functions will be an instance of the type of the argument for the corresponding set function. For example, in the accept callback for <a method title="getTransform()">getTransform</a> the value will be a <a>DOMMatrix</a>.

<pre class='idl'>
interface AnimationProxy {
    Promise getTransform();
    Promise getOpacity();
    Promise getScrollOffset();

    Promise setTransform(DOMMatrix transform);
    Promise setOpacity(float opacity);
    Promise setScrollOffset(Point point);
};

enum AnimationProxyErrors {
    "proxiedElementWasDestroyed"
};
</pre>

The <dfn>DOMMatrix</dfn> interface is defined <a href="http://www.w3.org/TR/matrix/">here</a>.

NOTE: <a interface>AnimationProxy</a> is structured cloneable data and may be posted in messages between threads. It is permissible to use a proxy on multiple threads, but due to asynchrony, this may result in undefined behavior: there will be contention for the properties of the proxied element.

<h3 id="worker-animation-timing-interface">The WebWorkerAnimationTiming Interface</h3>

<a interface>AnimationProxy</a> instances are intended for animation, and as such are most useful in the context of a <a method title="requestAnimationFrame()">requestAnimationFrame</a> callback. Ideally, this callback will be executed each frame, though that may not always be possible for all user agents. Since these callbacks may be asynchronous with respect to the compositor, it will be convenient to provide some timing information to these callbacks and to allow for atomic transactions. So rather than having a web worker implement <a href="http://www.w3.org/TR/animation-timing/">WindowAnimationTiming</a>, we define the following, very similar interface.

<pre class='idl'>
[NoInterfaceObject]
interface WebWorkerAnimationTiming {
    long requestAnimationFrame(AnimationFrameCallback callback);
    void cancelAnimationFrame(long handle);
};

WebWorker implements WebWorkerAnimationTiming;

callback interface AnimationFrameCallback {
    void animate(AnimationFrameContext context);
};

interface AnimationFrameContext {
    float progress();
    Promise beginTransaction(AnimationFrameCallback cb);
};

enum AnimationFrameContextErrors {
    "missedFrameDeadline"
};
</pre>

The <a interface>AnimationFrameContext</a>'s <a method title="progress()">progress</a> method returns the fractional number of frames since the start of the frame in which the <a method title="requestAnimationFrame()">requestAnimationFrame</a> callback was issued. For example, a value of 1.2 would indicate that we've passed one frame boundary since the callback was issued and we are 20% of the way through the next frame. A value greater than 1.0 indicates that <a method title="beginTransaction()">beginTransaction</a> will certainly fail (since we have missed the deadline for the current frame).

Any modification to <a interface>AnimationProxy</a> instances that occur in an <a callback>AnimationFrameCallback</a> passed to <a method title="beginTransaction()">beginTransaction</a> will be undone if the callback is unable to complete. Modifications to other, non-<a interface>AnimationProxy</a> values will not be rolled back, however. If a rollback was required, the <a interface>Promise</a>'s reject callback will be executed and its error attribute will be set to an enumerator of <a enum>AnimationFrameContextErrors</a>.

NOTE: It is the prerogative of the the user agent which thread the <a callback>AnimationFrameCallback</a> executes on. In particular, a user agent may choose to execute the callback on a thread in the compositor component to allow synchronous access to the compositor-owned, <a>layout free</a> properties. It may also choose to execute only a portion of the function on that thread to prevent unacceptable delays in the compositor component.
